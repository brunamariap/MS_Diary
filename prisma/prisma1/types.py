# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']

MetricsFormat = Literal['json', 'prometheus']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
            },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
            },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
            },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
            },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Grade types

class GradeOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Grade create method"""
    id: _str
    diaryId: _str
    diary: 'DiaryCreateNestedWithoutRelationsInput'


class GradeCreateInput(GradeOptionalCreateInput):
    """Required arguments to the Grade create method"""
    score: _int
    bimester: _int
    disciplineId: _str
    attributedBy: _str
    studentId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class GradeOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Grade create method, without relations"""
    id: _str
    diaryId: _str


class GradeCreateWithoutRelationsInput(GradeOptionalCreateWithoutRelationsInput):
    """Required arguments to the Grade create method, without relations"""
    score: _int
    bimester: _int
    disciplineId: _str
    attributedBy: _str
    studentId: _str


class GradeCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'GradeCreateWithoutRelationsInput'
    connect: 'GradeWhereUniqueInput'


class GradeCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['GradeCreateWithoutRelationsInput', List['GradeCreateWithoutRelationsInput']]
    connect: Union['GradeWhereUniqueInput', List['GradeWhereUniqueInput']]


_GradeWhereUnique_id_Input = TypedDict(
    '_GradeWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

GradeWhereUniqueInput = _GradeWhereUnique_id_Input


class GradeUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    score: Union[AtomicIntInput, _int]
    bimester: Union[AtomicIntInput, _int]
    disciplineId: _str
    attributedBy: _str
    studentId: _str
    diary: 'DiaryUpdateOneWithoutRelationsInput'


class GradeUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    score: Union[AtomicIntInput, _int]
    bimester: Union[AtomicIntInput, _int]
    disciplineId: _str
    attributedBy: _str
    studentId: _str


class GradeUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['GradeCreateWithoutRelationsInput']
    connect: List['GradeWhereUniqueInput']
    set: List['GradeWhereUniqueInput']
    disconnect: List['GradeWhereUniqueInput']
    delete: List['GradeWhereUniqueInput']

    # TODO
    # update: List['GradeUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['GradeUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['GradeScalarWhereInput']
    # upsert: List['GradeUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['GradeCreateOrConnectWithoutRelationsInput']


class GradeUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'GradeCreateWithoutRelationsInput'
    connect: 'GradeWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'GradeUpdateInput'
    # upsert: 'GradeUpsertWithoutRelationsInput'
    # connectOrCreate: 'GradeCreateOrConnectWithoutRelationsInput'


class GradeUpsertInput(TypedDict):
    create: 'GradeCreateInput'
    update: 'GradeUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Grade_id_OrderByInput = TypedDict(
    '_Grade_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Grade_score_OrderByInput = TypedDict(
    '_Grade_score_OrderByInput',
    {
        'score': 'SortOrder',
    },
    total=True
)

_Grade_bimester_OrderByInput = TypedDict(
    '_Grade_bimester_OrderByInput',
    {
        'bimester': 'SortOrder',
    },
    total=True
)

_Grade_disciplineId_OrderByInput = TypedDict(
    '_Grade_disciplineId_OrderByInput',
    {
        'disciplineId': 'SortOrder',
    },
    total=True
)

_Grade_attributedBy_OrderByInput = TypedDict(
    '_Grade_attributedBy_OrderByInput',
    {
        'attributedBy': 'SortOrder',
    },
    total=True
)

_Grade_studentId_OrderByInput = TypedDict(
    '_Grade_studentId_OrderByInput',
    {
        'studentId': 'SortOrder',
    },
    total=True
)

_Grade_diaryId_OrderByInput = TypedDict(
    '_Grade_diaryId_OrderByInput',
    {
        'diaryId': 'SortOrder',
    },
    total=True
)

GradeOrderByInput = Union[
    '_Grade_id_OrderByInput',
    '_Grade_score_OrderByInput',
    '_Grade_bimester_OrderByInput',
    '_Grade_disciplineId_OrderByInput',
    '_Grade_attributedBy_OrderByInput',
    '_Grade_studentId_OrderByInput',
    '_Grade_diaryId_OrderByInput',
]



# recursive Grade types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

GradeRelationFilter = TypedDict(
    'GradeRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class GradeListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class GradeInclude(TypedDict, total=False):
    """Grade relational arguments"""
    diary: Union[bool, 'DiaryArgsFromGrade']


    

class GradeIncludeFromGrade(TypedDict, total=False):
    """Relational arguments for Grade"""
    diary: Union[bool, 'DiaryArgsFromGradeRecursive1']


class GradeIncludeFromGradeRecursive1(TypedDict, total=False):
    """Relational arguments for Grade"""
    diary: Union[bool, 'DiaryArgsFromGradeRecursive2']


class GradeIncludeFromGradeRecursive2(TypedDict, total=False):
    """Relational arguments for Grade"""
    diary: Union[bool, 'DiaryArgsFromGradeRecursive3']


class GradeIncludeFromGradeRecursive3(TypedDict, total=False):
    """Relational arguments for Grade"""
    diary: Union[bool, 'DiaryArgsFromGradeRecursive4']


class GradeIncludeFromGradeRecursive4(TypedDict, total=False):
    """Relational arguments for Grade"""

    

class GradeArgsFromGrade(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'GradeIncludeFromGradeRecursive1'


class GradeArgsFromGradeRecursive1(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'GradeIncludeFromGradeRecursive2'


class GradeArgsFromGradeRecursive2(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'GradeIncludeFromGradeRecursive3'


class GradeArgsFromGradeRecursive3(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'GradeIncludeFromGradeRecursive4'


class GradeArgsFromGradeRecursive4(TypedDict, total=False):
    """Arguments for Grade"""
    
    

class FindManyGradeArgsFromGrade(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive1'


class FindManyGradeArgsFromGradeRecursive1(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive2'


class FindManyGradeArgsFromGradeRecursive2(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive3'


class FindManyGradeArgsFromGradeRecursive3(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive4'


class FindManyGradeArgsFromGradeRecursive4(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    
    

class DiaryIncludeFromGrade(TypedDict, total=False):
    """Relational arguments for Grade"""
    grade: Union[bool, 'FindManyGradeArgsFromGradeRecursive1']


class DiaryIncludeFromGradeRecursive1(TypedDict, total=False):
    """Relational arguments for Grade"""
    grade: Union[bool, 'FindManyGradeArgsFromGradeRecursive2']


class DiaryIncludeFromGradeRecursive2(TypedDict, total=False):
    """Relational arguments for Grade"""
    grade: Union[bool, 'FindManyGradeArgsFromGradeRecursive3']


class DiaryIncludeFromGradeRecursive3(TypedDict, total=False):
    """Relational arguments for Grade"""
    grade: Union[bool, 'FindManyGradeArgsFromGradeRecursive4']


class DiaryIncludeFromGradeRecursive4(TypedDict, total=False):
    """Relational arguments for Grade"""

    

class DiaryArgsFromGrade(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'DiaryIncludeFromDiaryRecursive1'


class DiaryArgsFromGradeRecursive1(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'DiaryIncludeFromDiaryRecursive2'


class DiaryArgsFromGradeRecursive2(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'DiaryIncludeFromDiaryRecursive3'


class DiaryArgsFromGradeRecursive3(TypedDict, total=False):
    """Arguments for Grade"""
    include: 'DiaryIncludeFromDiaryRecursive4'


class DiaryArgsFromGradeRecursive4(TypedDict, total=False):
    """Arguments for Grade"""
    
    

class FindManyDiaryArgsFromGrade(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive1'


class FindManyDiaryArgsFromGradeRecursive1(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive2'


class FindManyDiaryArgsFromGradeRecursive2(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive3'


class FindManyDiaryArgsFromGradeRecursive3(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive4'


class FindManyDiaryArgsFromGradeRecursive4(TypedDict, total=False):
    """Arguments for Grade"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    


FindManyGradeArgs = FindManyGradeArgsFromGrade
FindFirstGradeArgs = FindManyGradeArgsFromGrade


    

class GradeWhereInput(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    score: Union[_int, 'types.IntFilter']
    bimester: Union[_int, 'types.IntFilter']
    disciplineId: Union[_str, 'types.StringFilter']
    attributedBy: Union[_str, 'types.StringFilter']
    studentId: Union[_str, 'types.StringFilter']
    diaryId: Union[_str, 'types.StringFilter']
    diary: 'DiaryRelationFilter'

    # should be noted that AND and NOT should be Union['GradeWhereInputRecursive1', List['GradeWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['GradeWhereInputRecursive1']
    OR: List['GradeWhereInputRecursive1']
    NOT: List['GradeWhereInputRecursive1']


class GradeWhereInputRecursive1(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    score: Union[_int, 'types.IntFilter']
    bimester: Union[_int, 'types.IntFilter']
    disciplineId: Union[_str, 'types.StringFilter']
    attributedBy: Union[_str, 'types.StringFilter']
    studentId: Union[_str, 'types.StringFilter']
    diaryId: Union[_str, 'types.StringFilter']
    diary: 'DiaryRelationFilter'

    # should be noted that AND and NOT should be Union['GradeWhereInputRecursive2', List['GradeWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['GradeWhereInputRecursive2']
    OR: List['GradeWhereInputRecursive2']
    NOT: List['GradeWhereInputRecursive2']


class GradeWhereInputRecursive2(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    score: Union[_int, 'types.IntFilter']
    bimester: Union[_int, 'types.IntFilter']
    disciplineId: Union[_str, 'types.StringFilter']
    attributedBy: Union[_str, 'types.StringFilter']
    studentId: Union[_str, 'types.StringFilter']
    diaryId: Union[_str, 'types.StringFilter']
    diary: 'DiaryRelationFilter'

    # should be noted that AND and NOT should be Union['GradeWhereInputRecursive3', List['GradeWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['GradeWhereInputRecursive3']
    OR: List['GradeWhereInputRecursive3']
    NOT: List['GradeWhereInputRecursive3']


class GradeWhereInputRecursive3(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    score: Union[_int, 'types.IntFilter']
    bimester: Union[_int, 'types.IntFilter']
    disciplineId: Union[_str, 'types.StringFilter']
    attributedBy: Union[_str, 'types.StringFilter']
    studentId: Union[_str, 'types.StringFilter']
    diaryId: Union[_str, 'types.StringFilter']
    diary: 'DiaryRelationFilter'

    # should be noted that AND and NOT should be Union['GradeWhereInputRecursive4', List['GradeWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['GradeWhereInputRecursive4']
    OR: List['GradeWhereInputRecursive4']
    NOT: List['GradeWhereInputRecursive4']


class GradeWhereInputRecursive4(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    score: Union[_int, 'types.IntFilter']
    bimester: Union[_int, 'types.IntFilter']
    disciplineId: Union[_str, 'types.StringFilter']
    attributedBy: Union[_str, 'types.StringFilter']
    studentId: Union[_str, 'types.StringFilter']
    diaryId: Union[_str, 'types.StringFilter']
    diary: 'DiaryRelationFilter'



# aggregate Grade types


    

class GradeScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    bimester: Union[_int, 'types.IntWithAggregatesFilter']
    disciplineId: Union[_str, 'types.StringWithAggregatesFilter']
    attributedBy: Union[_str, 'types.StringWithAggregatesFilter']
    studentId: Union[_str, 'types.StringWithAggregatesFilter']
    diaryId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GradeScalarWhereWithAggregatesInputRecursive1']
    OR: List['GradeScalarWhereWithAggregatesInputRecursive1']
    NOT: List['GradeScalarWhereWithAggregatesInputRecursive1']


class GradeScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    bimester: Union[_int, 'types.IntWithAggregatesFilter']
    disciplineId: Union[_str, 'types.StringWithAggregatesFilter']
    attributedBy: Union[_str, 'types.StringWithAggregatesFilter']
    studentId: Union[_str, 'types.StringWithAggregatesFilter']
    diaryId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GradeScalarWhereWithAggregatesInputRecursive2']
    OR: List['GradeScalarWhereWithAggregatesInputRecursive2']
    NOT: List['GradeScalarWhereWithAggregatesInputRecursive2']


class GradeScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    bimester: Union[_int, 'types.IntWithAggregatesFilter']
    disciplineId: Union[_str, 'types.StringWithAggregatesFilter']
    attributedBy: Union[_str, 'types.StringWithAggregatesFilter']
    studentId: Union[_str, 'types.StringWithAggregatesFilter']
    diaryId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GradeScalarWhereWithAggregatesInputRecursive3']
    OR: List['GradeScalarWhereWithAggregatesInputRecursive3']
    NOT: List['GradeScalarWhereWithAggregatesInputRecursive3']


class GradeScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    bimester: Union[_int, 'types.IntWithAggregatesFilter']
    disciplineId: Union[_str, 'types.StringWithAggregatesFilter']
    attributedBy: Union[_str, 'types.StringWithAggregatesFilter']
    studentId: Union[_str, 'types.StringWithAggregatesFilter']
    diaryId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['GradeScalarWhereWithAggregatesInputRecursive4']
    OR: List['GradeScalarWhereWithAggregatesInputRecursive4']
    NOT: List['GradeScalarWhereWithAggregatesInputRecursive4']


class GradeScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Grade arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_int, 'types.IntWithAggregatesFilter']
    bimester: Union[_int, 'types.IntWithAggregatesFilter']
    disciplineId: Union[_str, 'types.StringWithAggregatesFilter']
    attributedBy: Union[_str, 'types.StringWithAggregatesFilter']
    studentId: Union[_str, 'types.StringWithAggregatesFilter']
    diaryId: Union[_str, 'types.StringWithAggregatesFilter']



class GradeGroupByOutput(TypedDict, total=False):
    id: _str
    score: _int
    bimester: _int
    disciplineId: _str
    attributedBy: _str
    studentId: _str
    diaryId: _str
    _sum: 'GradeSumAggregateOutput'
    _avg: 'GradeAvgAggregateOutput'
    _min: 'GradeMinAggregateOutput'
    _max: 'GradeMaxAggregateOutput'
    _count: 'GradeCountAggregateOutput'


class GradeAvgAggregateOutput(TypedDict, total=False):
    """Grade output for aggregating averages"""
    score: float
    bimester: float


class GradeSumAggregateOutput(TypedDict, total=False):
    """Grade output for aggregating sums"""
    score: _int
    bimester: _int


class GradeScalarAggregateOutput(TypedDict, total=False):
    """Grade output including scalar fields"""
    id: _str
    score: _int
    bimester: _int
    disciplineId: _str
    attributedBy: _str
    studentId: _str
    diaryId: _str


GradeMinAggregateOutput = GradeScalarAggregateOutput
GradeMaxAggregateOutput = GradeScalarAggregateOutput


class GradeMaxAggregateInput(TypedDict, total=False):
    """Grade input for aggregating by max"""
    id: bool
    score: bool
    bimester: bool
    disciplineId: bool
    attributedBy: bool
    studentId: bool
    diaryId: bool


class GradeMinAggregateInput(TypedDict, total=False):
    """Grade input for aggregating by min"""
    id: bool
    score: bool
    bimester: bool
    disciplineId: bool
    attributedBy: bool
    studentId: bool
    diaryId: bool


class GradeNumberAggregateInput(TypedDict, total=False):
    """Grade input for aggregating numbers"""
    score: bool
    bimester: bool


GradeAvgAggregateInput = GradeNumberAggregateInput
GradeSumAggregateInput = GradeNumberAggregateInput


GradeCountAggregateInput = TypedDict(
    'GradeCountAggregateInput',
    {
        'id': bool,
        'score': bool,
        'bimester': bool,
        'disciplineId': bool,
        'attributedBy': bool,
        'studentId': bool,
        'diaryId': bool,
        '_all': bool,
    },
    total=False,
)

GradeCountAggregateOutput = TypedDict(
    'GradeCountAggregateOutput',
    {
        'id': int,
        'score': int,
        'bimester': int,
        'disciplineId': int,
        'attributedBy': int,
        'studentId': int,
        'diaryId': int,
        '_all': int,
    },
    total=False,
)


GradeKeys = Literal[
    'id',
    'score',
    'bimester',
    'disciplineId',
    'attributedBy',
    'studentId',
    'diaryId',
    'diary',
]
GradeScalarFieldKeys = Literal[
    'id',
    'score',
    'bimester',
    'disciplineId',
    'attributedBy',
    'studentId',
    'diaryId',
]
GradeScalarFieldKeysT = TypeVar('GradeScalarFieldKeysT', bound=GradeScalarFieldKeys)

GradeRelationalFieldKeys = Literal[
        'diary',
    ]

# Diary types

class DiaryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Diary create method"""
    id: _str
    grade: 'GradeCreateManyNestedWithoutRelationsInput'


class DiaryCreateInput(DiaryOptionalCreateInput):
    """Required arguments to the Diary create method"""
    referencePeriod: _int
    referenceYear: _int
    startDate: datetime.datetime
    endDate: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class DiaryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Diary create method, without relations"""
    id: _str


class DiaryCreateWithoutRelationsInput(DiaryOptionalCreateWithoutRelationsInput):
    """Required arguments to the Diary create method, without relations"""
    referencePeriod: _int
    referenceYear: _int
    startDate: datetime.datetime
    endDate: datetime.datetime


class DiaryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DiaryCreateWithoutRelationsInput'
    connect: 'DiaryWhereUniqueInput'


class DiaryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DiaryCreateWithoutRelationsInput', List['DiaryCreateWithoutRelationsInput']]
    connect: Union['DiaryWhereUniqueInput', List['DiaryWhereUniqueInput']]


_DiaryWhereUnique_id_Input = TypedDict(
    '_DiaryWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

DiaryWhereUniqueInput = _DiaryWhereUnique_id_Input


class DiaryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    referencePeriod: Union[AtomicIntInput, _int]
    referenceYear: Union[AtomicIntInput, _int]
    startDate: datetime.datetime
    endDate: datetime.datetime
    grade: 'GradeUpdateManyWithoutRelationsInput'


class DiaryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    referencePeriod: Union[AtomicIntInput, _int]
    referenceYear: Union[AtomicIntInput, _int]
    startDate: datetime.datetime
    endDate: datetime.datetime


class DiaryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DiaryCreateWithoutRelationsInput']
    connect: List['DiaryWhereUniqueInput']
    set: List['DiaryWhereUniqueInput']
    disconnect: List['DiaryWhereUniqueInput']
    delete: List['DiaryWhereUniqueInput']

    # TODO
    # update: List['DiaryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DiaryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DiaryScalarWhereInput']
    # upsert: List['DiaryUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['DiaryCreateOrConnectWithoutRelationsInput']


class DiaryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DiaryCreateWithoutRelationsInput'
    connect: 'DiaryWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DiaryUpdateInput'
    # upsert: 'DiaryUpsertWithoutRelationsInput'
    # connectOrCreate: 'DiaryCreateOrConnectWithoutRelationsInput'


class DiaryUpsertInput(TypedDict):
    create: 'DiaryCreateInput'
    update: 'DiaryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Diary_id_OrderByInput = TypedDict(
    '_Diary_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Diary_referencePeriod_OrderByInput = TypedDict(
    '_Diary_referencePeriod_OrderByInput',
    {
        'referencePeriod': 'SortOrder',
    },
    total=True
)

_Diary_referenceYear_OrderByInput = TypedDict(
    '_Diary_referenceYear_OrderByInput',
    {
        'referenceYear': 'SortOrder',
    },
    total=True
)

_Diary_startDate_OrderByInput = TypedDict(
    '_Diary_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_Diary_endDate_OrderByInput = TypedDict(
    '_Diary_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

DiaryOrderByInput = Union[
    '_Diary_id_OrderByInput',
    '_Diary_referencePeriod_OrderByInput',
    '_Diary_referenceYear_OrderByInput',
    '_Diary_startDate_OrderByInput',
    '_Diary_endDate_OrderByInput',
]



# recursive Diary types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

DiaryRelationFilter = TypedDict(
    'DiaryRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class DiaryListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class DiaryInclude(TypedDict, total=False):
    """Diary relational arguments"""
    grade: Union[bool, 'FindManyGradeArgsFromDiary']


    

class GradeIncludeFromDiary(TypedDict, total=False):
    """Relational arguments for Diary"""
    diary: Union[bool, 'DiaryArgsFromDiaryRecursive1']


class GradeIncludeFromDiaryRecursive1(TypedDict, total=False):
    """Relational arguments for Diary"""
    diary: Union[bool, 'DiaryArgsFromDiaryRecursive2']


class GradeIncludeFromDiaryRecursive2(TypedDict, total=False):
    """Relational arguments for Diary"""
    diary: Union[bool, 'DiaryArgsFromDiaryRecursive3']


class GradeIncludeFromDiaryRecursive3(TypedDict, total=False):
    """Relational arguments for Diary"""
    diary: Union[bool, 'DiaryArgsFromDiaryRecursive4']


class GradeIncludeFromDiaryRecursive4(TypedDict, total=False):
    """Relational arguments for Diary"""

    

class GradeArgsFromDiary(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'GradeIncludeFromGradeRecursive1'


class GradeArgsFromDiaryRecursive1(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'GradeIncludeFromGradeRecursive2'


class GradeArgsFromDiaryRecursive2(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'GradeIncludeFromGradeRecursive3'


class GradeArgsFromDiaryRecursive3(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'GradeIncludeFromGradeRecursive4'


class GradeArgsFromDiaryRecursive4(TypedDict, total=False):
    """Arguments for Diary"""
    
    

class FindManyGradeArgsFromDiary(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive1'


class FindManyGradeArgsFromDiaryRecursive1(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive2'


class FindManyGradeArgsFromDiaryRecursive2(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive3'


class FindManyGradeArgsFromDiaryRecursive3(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    include: 'GradeIncludeFromGradeRecursive4'


class FindManyGradeArgsFromDiaryRecursive4(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['GradeOrderByInput', List['GradeOrderByInput']]
    where: 'GradeWhereInput'
    cursor: 'GradeWhereUniqueInput'
    distinct: List['GradeScalarFieldKeys']
    
    

class DiaryIncludeFromDiary(TypedDict, total=False):
    """Relational arguments for Diary"""
    grade: Union[bool, 'FindManyGradeArgsFromDiaryRecursive1']


class DiaryIncludeFromDiaryRecursive1(TypedDict, total=False):
    """Relational arguments for Diary"""
    grade: Union[bool, 'FindManyGradeArgsFromDiaryRecursive2']


class DiaryIncludeFromDiaryRecursive2(TypedDict, total=False):
    """Relational arguments for Diary"""
    grade: Union[bool, 'FindManyGradeArgsFromDiaryRecursive3']


class DiaryIncludeFromDiaryRecursive3(TypedDict, total=False):
    """Relational arguments for Diary"""
    grade: Union[bool, 'FindManyGradeArgsFromDiaryRecursive4']


class DiaryIncludeFromDiaryRecursive4(TypedDict, total=False):
    """Relational arguments for Diary"""

    

class DiaryArgsFromDiary(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'DiaryIncludeFromDiaryRecursive1'


class DiaryArgsFromDiaryRecursive1(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'DiaryIncludeFromDiaryRecursive2'


class DiaryArgsFromDiaryRecursive2(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'DiaryIncludeFromDiaryRecursive3'


class DiaryArgsFromDiaryRecursive3(TypedDict, total=False):
    """Arguments for Diary"""
    include: 'DiaryIncludeFromDiaryRecursive4'


class DiaryArgsFromDiaryRecursive4(TypedDict, total=False):
    """Arguments for Diary"""
    
    

class FindManyDiaryArgsFromDiary(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive1'


class FindManyDiaryArgsFromDiaryRecursive1(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive2'


class FindManyDiaryArgsFromDiaryRecursive2(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive3'


class FindManyDiaryArgsFromDiaryRecursive3(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    include: 'DiaryIncludeFromDiaryRecursive4'


class FindManyDiaryArgsFromDiaryRecursive4(TypedDict, total=False):
    """Arguments for Diary"""
    take: int
    skip: int
    order_by: Union['DiaryOrderByInput', List['DiaryOrderByInput']]
    where: 'DiaryWhereInput'
    cursor: 'DiaryWhereUniqueInput'
    distinct: List['DiaryScalarFieldKeys']
    


FindManyDiaryArgs = FindManyDiaryArgsFromDiary
FindFirstDiaryArgs = FindManyDiaryArgsFromDiary


    

class DiaryWhereInput(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referencePeriod: Union[_int, 'types.IntFilter']
    referenceYear: Union[_int, 'types.IntFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    grade: 'GradeListRelationFilter'

    # should be noted that AND and NOT should be Union['DiaryWhereInputRecursive1', List['DiaryWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['DiaryWhereInputRecursive1']
    OR: List['DiaryWhereInputRecursive1']
    NOT: List['DiaryWhereInputRecursive1']


class DiaryWhereInputRecursive1(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referencePeriod: Union[_int, 'types.IntFilter']
    referenceYear: Union[_int, 'types.IntFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    grade: 'GradeListRelationFilter'

    # should be noted that AND and NOT should be Union['DiaryWhereInputRecursive2', List['DiaryWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['DiaryWhereInputRecursive2']
    OR: List['DiaryWhereInputRecursive2']
    NOT: List['DiaryWhereInputRecursive2']


class DiaryWhereInputRecursive2(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referencePeriod: Union[_int, 'types.IntFilter']
    referenceYear: Union[_int, 'types.IntFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    grade: 'GradeListRelationFilter'

    # should be noted that AND and NOT should be Union['DiaryWhereInputRecursive3', List['DiaryWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['DiaryWhereInputRecursive3']
    OR: List['DiaryWhereInputRecursive3']
    NOT: List['DiaryWhereInputRecursive3']


class DiaryWhereInputRecursive3(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referencePeriod: Union[_int, 'types.IntFilter']
    referenceYear: Union[_int, 'types.IntFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    grade: 'GradeListRelationFilter'

    # should be noted that AND and NOT should be Union['DiaryWhereInputRecursive4', List['DiaryWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['DiaryWhereInputRecursive4']
    OR: List['DiaryWhereInputRecursive4']
    NOT: List['DiaryWhereInputRecursive4']


class DiaryWhereInputRecursive4(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referencePeriod: Union[_int, 'types.IntFilter']
    referenceYear: Union[_int, 'types.IntFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    grade: 'GradeListRelationFilter'



# aggregate Diary types


    

class DiaryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referencePeriod: Union[_int, 'types.IntWithAggregatesFilter']
    referenceYear: Union[_int, 'types.IntWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DiaryScalarWhereWithAggregatesInputRecursive1']
    OR: List['DiaryScalarWhereWithAggregatesInputRecursive1']
    NOT: List['DiaryScalarWhereWithAggregatesInputRecursive1']


class DiaryScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referencePeriod: Union[_int, 'types.IntWithAggregatesFilter']
    referenceYear: Union[_int, 'types.IntWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DiaryScalarWhereWithAggregatesInputRecursive2']
    OR: List['DiaryScalarWhereWithAggregatesInputRecursive2']
    NOT: List['DiaryScalarWhereWithAggregatesInputRecursive2']


class DiaryScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referencePeriod: Union[_int, 'types.IntWithAggregatesFilter']
    referenceYear: Union[_int, 'types.IntWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DiaryScalarWhereWithAggregatesInputRecursive3']
    OR: List['DiaryScalarWhereWithAggregatesInputRecursive3']
    NOT: List['DiaryScalarWhereWithAggregatesInputRecursive3']


class DiaryScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referencePeriod: Union[_int, 'types.IntWithAggregatesFilter']
    referenceYear: Union[_int, 'types.IntWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DiaryScalarWhereWithAggregatesInputRecursive4']
    OR: List['DiaryScalarWhereWithAggregatesInputRecursive4']
    NOT: List['DiaryScalarWhereWithAggregatesInputRecursive4']


class DiaryScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Diary arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referencePeriod: Union[_int, 'types.IntWithAggregatesFilter']
    referenceYear: Union[_int, 'types.IntWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class DiaryGroupByOutput(TypedDict, total=False):
    id: _str
    referencePeriod: _int
    referenceYear: _int
    startDate: datetime.datetime
    endDate: datetime.datetime
    _sum: 'DiarySumAggregateOutput'
    _avg: 'DiaryAvgAggregateOutput'
    _min: 'DiaryMinAggregateOutput'
    _max: 'DiaryMaxAggregateOutput'
    _count: 'DiaryCountAggregateOutput'


class DiaryAvgAggregateOutput(TypedDict, total=False):
    """Diary output for aggregating averages"""
    referencePeriod: float
    referenceYear: float


class DiarySumAggregateOutput(TypedDict, total=False):
    """Diary output for aggregating sums"""
    referencePeriod: _int
    referenceYear: _int


class DiaryScalarAggregateOutput(TypedDict, total=False):
    """Diary output including scalar fields"""
    id: _str
    referencePeriod: _int
    referenceYear: _int
    startDate: datetime.datetime
    endDate: datetime.datetime


DiaryMinAggregateOutput = DiaryScalarAggregateOutput
DiaryMaxAggregateOutput = DiaryScalarAggregateOutput


class DiaryMaxAggregateInput(TypedDict, total=False):
    """Diary input for aggregating by max"""
    id: bool
    referencePeriod: bool
    referenceYear: bool
    startDate: bool
    endDate: bool


class DiaryMinAggregateInput(TypedDict, total=False):
    """Diary input for aggregating by min"""
    id: bool
    referencePeriod: bool
    referenceYear: bool
    startDate: bool
    endDate: bool


class DiaryNumberAggregateInput(TypedDict, total=False):
    """Diary input for aggregating numbers"""
    referencePeriod: bool
    referenceYear: bool


DiaryAvgAggregateInput = DiaryNumberAggregateInput
DiarySumAggregateInput = DiaryNumberAggregateInput


DiaryCountAggregateInput = TypedDict(
    'DiaryCountAggregateInput',
    {
        'id': bool,
        'referencePeriod': bool,
        'referenceYear': bool,
        'startDate': bool,
        'endDate': bool,
        '_all': bool,
    },
    total=False,
)

DiaryCountAggregateOutput = TypedDict(
    'DiaryCountAggregateOutput',
    {
        'id': int,
        'referencePeriod': int,
        'referenceYear': int,
        'startDate': int,
        'endDate': int,
        '_all': int,
    },
    total=False,
)


DiaryKeys = Literal[
    'id',
    'referencePeriod',
    'referenceYear',
    'startDate',
    'endDate',
    'grade',
]
DiaryScalarFieldKeys = Literal[
    'id',
    'referencePeriod',
    'referenceYear',
    'startDate',
    'endDate',
]
DiaryScalarFieldKeysT = TypeVar('DiaryScalarFieldKeysT', bound=DiaryScalarFieldKeys)

DiaryRelationalFieldKeys = Literal[
        'grade',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields